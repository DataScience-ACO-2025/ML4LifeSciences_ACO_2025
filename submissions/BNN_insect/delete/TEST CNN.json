{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"ff7a7e35-155a-4e0e-858c-cad14d10e615","executionInfo":{"status":"ok","timestamp":1762782454989,"user_tz":-60,"elapsed":12750,"user":{"displayName":"Thibault Roattino","userId":"04348901344521168705"}}},"outputs":[],"source":["import torch\n","import torch.nn as nn\n","import torchvision.transforms as transforms\n","from torchvision import datasets\n","from torch.utils.data import DataLoader\n","import torch.optim as optim"],"id":"ff7a7e35-155a-4e0e-858c-cad14d10e615"},{"cell_type":"code","source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","!nvidia-smi # permet de voir si le gpu est bien utilisé mais j'arrive pas a trouver ou voir l'info mdr\n","\n","# OPTIMISATIONS PYTORCH\n","torch.backends.cudnn.benchmark = True  # Accélère les convolutions pour des tailles d’images fixes\n","device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n","print(\"Utilisation de :\", device)\n"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"ohXdypg_qj1y","executionInfo":{"status":"ok","timestamp":1762781708936,"user_tz":-60,"elapsed":1192,"user":{"displayName":"Matéo Rosa","userId":"13422827768393665107"}},"outputId":"3f90a826-bf72-426a-ef95-d13d4d1addd5"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n","Mon Nov 10 13:35:13 2025       \n","+-----------------------------------------------------------------------------------------+\n","| NVIDIA-SMI 550.54.15              Driver Version: 550.54.15      CUDA Version: 12.4     |\n","|-----------------------------------------+------------------------+----------------------+\n","| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |\n","| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |\n","|                                         |                        |               MIG M. |\n","|=========================================+========================+======================|\n","|   0  Tesla T4                       Off |   00000000:00:04.0 Off |                    0 |\n","| N/A   61C    P8             10W /   70W |       0MiB /  15360MiB |      0%      Default |\n","|                                         |                        |                  N/A |\n","+-----------------------------------------+------------------------+----------------------+\n","                                                                                         \n","+-----------------------------------------------------------------------------------------+\n","| Processes:                                                                              |\n","|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |\n","|        ID   ID                                                               Usage      |\n","|=========================================================================================|\n","|  No running processes found                                                             |\n","+-----------------------------------------------------------------------------------------+\n","Utilisation de : cuda\n"]}],"id":"ohXdypg_qj1y"},{"cell_type":"markdown","id":"689aa6c1-18e9-4f19-99b4-537cf2e9c476","metadata":{"id":"689aa6c1-18e9-4f19-99b4-537cf2e9c476"},"source":["Implementation de AlexNet\n","\n","Imporation des libraries"]},{"cell_type":"markdown","id":"747e6f70-27bf-49aa-abda-ded64c93c1a5","metadata":{"id":"747e6f70-27bf-49aa-abda-ded64c93c1a5"},"source":["Creation de l'architecture\n","##########################\n","\n","-Feature Extractor:\n","La première couche de convolution prend une image à 3 canaux et passe un kernel de taille 11x11 avec un pas de 4 réduit.\n","Les fonction d'activation sont des ReLu (conserve les y positives et renvoi 0 pour les y négatifs)\n","Ensuite, un maxpooling est appliqué pour réduire la dimension des images et concerver les informations importantes\n","\n","-Classifier:\n","Ensemble de percptron multi-couches avec des fonction d'activation ReLu\n","Les features (les x) sont projetées dans un espace de grande dimension ici de taille 4096. La dernière couches est la sortie du reseau\n","\n","-Forward:\n","Calcul du lien entre les entrées et les sorties (f(x)) ou on défini le passage des entrées dans le Feature extractor, les features sont transformées en vecteur (fletten) puis les vecteurs de features sont passées dans les PMC."]},{"cell_type":"code","execution_count":null,"id":"939d9887-7114-4e17-b3d8-9cfe1b582974","metadata":{"id":"939d9887-7114-4e17-b3d8-9cfe1b582974"},"outputs":[],"source":["class AlexNet(nn.Module):\n","    def __init__(self, num_classes=1000): #num_classes a modifier en fonction du nombre de sorties souhaité\n","        super(AlexNet, self).__init__()\n","\n","        # Feature Extractor = couches de convolution et pooling\n","        self.features = nn.Sequential(\n","            nn.Conv2d(3, 64, kernel_size=11, stride=4, padding=2),  # Conv1\n","            nn.ReLU(inplace=True),\n","            nn.MaxPool2d(kernel_size=3, stride=2),  # MaxPool1\n","            nn.Conv2d(64, 192, kernel_size=5, padding=2),  # Conv2\n","            nn.ReLU(inplace=True),\n","            nn.MaxPool2d(kernel_size=3, stride=2),  # MaxPool2\n","            nn.Conv2d(192, 384, kernel_size=3, padding=1),  # Conv3\n","            nn.ReLU(inplace=True),\n","            nn.Conv2d(384, 256, kernel_size=3, padding=1),  # Conv4\n","            nn.ReLU(inplace=True),\n","            nn.Conv2d(256, 256, kernel_size=3, padding=1),  # Conv5\n","            nn.ReLU(inplace=True),\n","            nn.MaxPool2d(kernel_size=3, stride=2),  # MaxPool3\n","        )\n","\n","        # Classifier = couches de PMC\n","        self.classifier = nn.Sequential(\n","            nn.Dropout(),\n","            nn.Linear(256 * 6 * 6, 4096),\n","            nn.ReLU(inplace=True),\n","            nn.Dropout(),\n","            nn.Linear(4096, 4096),\n","            nn.ReLU(inplace=True),\n","            nn.Linear(4096, num_classes),  #Couche de sortie\n","        )\n","\n","    #Calcul des f(x)\n","    def forward(self, x):\n","        x = self.features(x)  # Calcul a traver les couches de convolution\n","        x = torch.flatten(x, 1)  # Les sorties de la convolution sont transformées en vecteurs pour être utilisable par les PMC\n","        x = self.classifier(x)  # Calcul a traver les couches de PMC\n","        return x"]},{"cell_type":"markdown","id":"185af5e3-263f-4e77-9009-091071e675f5","metadata":{"id":"185af5e3-263f-4e77-9009-091071e675f5"},"source":["Traitement des données\n","######################\n","\n","-Transformation des données:\n","Ici la taille des images est modifiée, les images sont converties en tenseurs et enfin normalisées. En effet, AlexNet doit traiter des images en 227x227 pixels. Le normalisation permet une convergence plus rapide.\n","\n","-Chargement des données\n","\n","-Création d'un dataloader"]},{"cell_type":"code","execution_count":null,"id":"5a79dae2-f99f-4fd7-8848-5c00f1287fb8","metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"5a79dae2-f99f-4fd7-8848-5c00f1287fb8","executionInfo":{"status":"ok","timestamp":1762781709002,"user_tz":-60,"elapsed":50,"user":{"displayName":"Matéo Rosa","userId":"13422827768393665107"}},"outputId":"73cbb43c-73f8-4a6e-bacf-12f7052da69b"},"outputs":[{"output_type":"stream","name":"stdout","text":["Nombre d'images total : 2548\n","Train : 2038, Test : 510\n","Classes : ['ant', 'bee', 'bug']\n"]}],"source":["from torchvision import datasets, transforms\n","from torch.utils.data import DataLoader, random_split\n","\n","# Transformation des données\n","transform = transforms.Compose([\n","    transforms.Resize((227, 227)),\n","    transforms.ToTensor(),\n","    transforms.Normalize(mean=[0.485, 0.456, 0.406],\n","                         std=[0.229, 0.224, 0.225]),\n","])\n","\n","# Chargement du dataset\n","root = r\"/content/drive/MyDrive/PROJET BAYESIEN/DATA/data_test_bug_ant_bee\"\n","\n","dataset = datasets.ImageFolder(root=root, transform=transform)\n","\n","# Division en train / test\n","train_size = int(0.8 * len(dataset))\n","test_size = len(dataset) - train_size\n","\n","train_dataset, test_dataset = random_split(dataset, [train_size, test_size])\n","\n","# DataLoaders\n","train_loader = DataLoader(\n","    train_dataset, batch_size=128, shuffle=True,\n","    num_workers=0, pin_memory=True, persistent_workers=False\n",")\n","test_loader = DataLoader(\n","    test_dataset, batch_size=128, shuffle=False,\n","    num_workers=0, pin_memory=True, persistent_workers=False\n",")\n","\n","print(f\"Nombre d'images total : {len(dataset)}\")\n","print(f\"Train : {len(train_dataset)}, Test : {test_size}\")\n","print(f\"Classes : {dataset.classes}\")"]},{"cell_type":"markdown","id":"2390d4b3-436b-462f-a5a0-c3ce9574b75f","metadata":{"id":"2390d4b3-436b-462f-a5a0-c3ce9574b75f"},"source":["Entrainement du modèle\n","######################\n","\n","-Définition du modèle:\n","On défini notre modèle comme étant l'architecture générée en partie \"Creation de l'architecture\".\n","\n","-Fonction loss:\n","Définition de la fonction loss qui est ici une crossentropy.\n","\n","-Optimizeer:\n","Définition de la descente de gradient"]},{"cell_type":"code","execution_count":null,"id":"905c3a1a-1c10-4a29-88d0-21127865d351","metadata":{"id":"905c3a1a-1c10-4a29-88d0-21127865d351"},"outputs":[],"source":["# Définition du modèle\n","model = AlexNet(num_classes=3).to('cuda')  # Move model to GPU\n","\n","# Fonction loss\n","criterion = nn.CrossEntropyLoss()\n","\n","# Optimizer\n","optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9, weight_decay=0.0005)\n","\n","# Scheduler (permet d'optimiser le learning rate à chaque epoch, ici on l'a setup a se mettre a jour tt les 5 epoch)\n","scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=5, gamma=0.1)"]},{"cell_type":"markdown","id":"49b3cc53-17c7-472c-bd50-da691629efcb","metadata":{"id":"49b3cc53-17c7-472c-bd50-da691629efcb"},"source":["Boucle d'entrainnement\n","######################\n","\n","-Calcul des y^ avec la fonction forward\n","\n","-Mis a jour des poids avec la fonction backward"]},{"cell_type":"code","execution_count":null,"id":"67e05216-bb74-4359-b4c3-4d7addf34303","metadata":{"id":"67e05216-bb74-4359-b4c3-4d7addf34303","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1762781825139,"user_tz":-60,"elapsed":115518,"user":{"displayName":"Matéo Rosa","userId":"13422827768393665107"}},"outputId":"81bf7f62-df84-4659-8b54-8d7492c72241"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mon Nov 10 13:35:14 2025       \n","+-----------------------------------------------------------------------------------------+\n","| NVIDIA-SMI 550.54.15              Driver Version: 550.54.15      CUDA Version: 12.4     |\n","|-----------------------------------------+------------------------+----------------------+\n","| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |\n","| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |\n","|                                         |                        |               MIG M. |\n","|=========================================+========================+======================|\n","|   0  Tesla T4                       Off |   00000000:00:04.0 Off |                    0 |\n","| N/A   62C    P0             28W /   70W |     332MiB /  15360MiB |      0%      Default |\n","|                                         |                        |                  N/A |\n","+-----------------------------------------+------------------------+----------------------+\n","                                                                                         \n","+-----------------------------------------------------------------------------------------+\n","| Processes:                                                                              |\n","|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |\n","|        ID   ID                                                               Usage      |\n","|=========================================================================================|\n","+-----------------------------------------------------------------------------------------+\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [1/10] - Loss: 1.0802\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [2/10] - Loss: 1.0210\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [3/10] - Loss: 0.9984\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [4/10] - Loss: 0.9769\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [5/10] - Loss: 0.9296\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [6/10] - Loss: 0.8698\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [7/10] - Loss: 0.8479\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [8/10] - Loss: 0.8284\n"]},{"output_type":"stream","name":"stderr","text":[]},{"output_type":"stream","name":"stdout","text":["Epoch [9/10] - Loss: 0.8060\n"]},{"output_type":"stream","name":"stderr","text":["                                                            "]},{"output_type":"stream","name":"stdout","text":["Epoch [10/10] - Loss: 0.7864\n"]},{"output_type":"stream","name":"stderr","text":["\r"]}],"source":["!nvidia-smi\n","\n","num_epochs = 10\n","\n","from tqdm import tqdm  # barre de progression utile\n","num_epochs = 10\n","\n","for epoch in range(num_epochs):\n","    model.train()\n","    running_loss = 0.0\n","\n","    for images, labels in tqdm(train_loader, desc=f\"Epoch {epoch+1}/{num_epochs}\", leave=False):\n","        try:\n","            images, labels = images.to(device, non_blocking=True), labels.to(device, non_blocking=True)\n","        except Exception as e:\n","            print(f\"Error loading data for epoch {epoch+1}: {e}\")\n","            continue # Skip this batch and continue with the next\n","\n","        optimizer.zero_grad(set_to_none=True)\n","        outputs = model(images)\n","        loss = criterion(outputs, labels)\n","        loss.backward()\n","        optimizer.step()\n","\n","        running_loss += loss.item()\n","\n","    scheduler.step()  # on met à jour le learning rate après l’epoch\n","\n","    avg_loss = running_loss / len(train_loader)\n","    print(f\"Epoch [{epoch+1}/{num_epochs}] - Loss: {avg_loss:.4f}\")"]},{"cell_type":"markdown","id":"223191e5-df37-45a5-81d8-02eccb52fefd","metadata":{"id":"223191e5-df37-45a5-81d8-02eccb52fefd"},"source":["Validation\n","##########\n","\n","Permet de tester la capacité du modèle à généraliser. Ici on ne fait pas l'étape backward car on ne veut pas mettre a jour les poids, mais on réalise uniquement l'étape forward pour réaliser les prédictions"]},{"cell_type":"code","execution_count":null,"id":"5dd7c348-b149-4465-9a0e-fb546914c757","metadata":{"id":"5dd7c348-b149-4465-9a0e-fb546914c757","executionInfo":{"status":"ok","timestamp":1762781828720,"user_tz":-60,"elapsed":3573,"user":{"displayName":"Matéo Rosa","userId":"13422827768393665107"}},"colab":{"base_uri":"https://localhost:8080/"},"outputId":"eb7b1dc0-c409-41c5-a01e-bae1ae3dbb1f"},"outputs":[{"output_type":"stream","name":"stdout","text":["Accuracy: 74.51%\n"]}],"source":["model.eval()  # On déclare qu'on est en validation\n","total, correct = 0, 0  # Suivi des images bien classées\n","\n","with torch.no_grad():  # Désactivation du calcul du gradient\n","    for images, labels in test_loader:\n","        images, labels = images.to('cuda'), labels.to('cuda')  # Passage des données vers un GPU\n","        outputs = model(images)  # Forward\n","        _, predicted = outputs.max(1)  # Donne la prédiction\n","        total += labels.size(0)\n","        correct += (predicted == labels).sum().item()\n","\n","accuracy = 100 * correct / total\n","print(f'Accuracy: {accuracy:.2f}%')"]},{"cell_type":"markdown","source":["Fine-Tuning et transfert d'apprentissage\n","######################\n","\n","En remplaçant la dernière couche entièrement connectée (model.classifier[6]), on indique à AlexNet d'ajuster ses prédictions à votre ensemble de données personnalisé. Les couches antérieures restent intactes, conservant les caractéristiques apprises, tandis que la nouvelle couche apprend à classer vos catégories spécifiques."],"metadata":{"id":"PsMuvhlP2h2W"},"id":"PsMuvhlP2h2W"},{"cell_type":"code","source":["from torch import nn\n","from torchvision.models import alexnet\n","\n","# Importation du pre-trained AlexNet\n","model = alexnet(pretrained=True).to('cuda') # Move the model to GPU\n","\n","# modif de la dernière couche pour avoir que 3 classes + alexnet sur gpu\n","model.classifier[6] = nn.Linear(4096, 3).to('cuda')\n","\n","for param in model.features.parameters():\n","    param.requires_grad = False\n","\n","# optimizer\n","optimizer = optim.SGD(model.classifier.parameters(), lr=0.001, momentum=0.9)\n","\n","# criterion sur GPU\n","criterion = criterion.to('cuda')\n","\n","# Boucle train\n","num_epochs = 5\n","for epoch in range(num_epochs):\n","    model.train()\n","    running_loss = 0.0\n","\n","    for images, labels in train_loader:\n","        images, labels = images.to('cuda'), labels.to('cuda')\n","\n","        optimizer.zero_grad()\n","        outputs = model(images)\n","        loss = criterion(outputs, labels)\n","        loss.backward()\n","        optimizer.step()\n","\n","        running_loss += loss.item()\n","\n","    print(f\"Epoch [{epoch+1}/{num_epochs}], Loss: {running_loss/len(train_loader):.4f}\")"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"F8r3qqbg2hO-","executionInfo":{"status":"ok","timestamp":1762782192488,"user_tz":-60,"elapsed":52262,"user":{"displayName":"Matéo Rosa","userId":"13422827768393665107"}},"outputId":"7d91fc5f-3ac2-4d0b-ffb0-edf193ad12f2"},"id":"F8r3qqbg2hO-","execution_count":null,"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.12/dist-packages/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and may be removed in the future, please use 'weights' instead.\n","  warnings.warn(\n","/usr/local/lib/python3.12/dist-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=AlexNet_Weights.IMAGENET1K_V1`. You can also use `weights=AlexNet_Weights.DEFAULT` to get the most up-to-date weights.\n","  warnings.warn(msg)\n"]},{"output_type":"stream","name":"stdout","text":["Epoch [1/5], Loss: 0.6967\n","Epoch [2/5], Loss: 0.2952\n","Epoch [3/5], Loss: 0.2118\n","Epoch [4/5], Loss: 0.1875\n","Epoch [5/5], Loss: 0.1593\n"]}]},{"cell_type":"code","execution_count":null,"metadata":{"executionInfo":{"status":"ok","timestamp":1762782195717,"user_tz":-60,"elapsed":3219,"user":{"displayName":"Matéo Rosa","userId":"13422827768393665107"}},"colab":{"base_uri":"https://localhost:8080/"},"outputId":"11de1d08-12da-4ed2-e9bb-aa919aeb1c5e","id":"D11-c99e_lC5"},"outputs":[{"output_type":"stream","name":"stdout","text":["Accuracy: 94.71%\n"]}],"source":["model.eval()  # On déclare qu'on est en validation\n","total, correct = 0, 0  # Suivi des images bien classées\n","\n","with torch.no_grad():  # Désactivation du calcul du gradient\n","    for images, labels in test_loader:\n","        images, labels = images.to('cuda'), labels.to('cuda')  # Passage des données vers un GPU\n","        outputs = model(images)  # Forward\n","        _, predicted = outputs.max(1)  # Donne la prédiction\n","        total += labels.size(0)\n","        correct += (predicted == labels).sum().item()\n","\n","accuracy = 100 * correct / total\n","print(f'Accuracy: {accuracy:.2f}%')"],"id":"D11-c99e_lC5"}],"metadata":{"kernelspec":{"display_name":"Python [conda env:base] *","language":"python","name":"conda-base-py"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.13.5"},"colab":{"provenance":[],"gpuType":"T4"},"accelerator":"GPU"},"nbformat":4,"nbformat_minor":5}